{"meta":{"title":"Code & Life","subtitle":"","description":"为了更美好的明天而战。","author":"小可乐跟我走","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2021-01-07T15:27:53.000Z","updated":"2021-01-08T08:58:05.467Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"有什么想对我说的","date":"2021-01-07T15:17:29.000Z","updated":"2021-01-08T08:58:05.468Z","comments":true,"path":"guestbook/index.html","permalink":"http://example.com/guestbook/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2021-01-07T15:03:37.000Z","updated":"2021-01-08T08:58:05.468Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-01-07T03:28:33.083Z","updated":"2021-01-07T03:28:33.019Z","comments":true,"path":"markdown/draft/白屏监控.html","permalink":"http://example.com/markdown/draft/%E7%99%BD%E5%B1%8F%E7%9B%91%E6%8E%A7.html","excerpt":"","text":"白屏监控公司内部方案： warden前端监控使用用data-rye属性来标识关键节点 文字 图片 key-dom 监控思路 从根往下遍历节点 检测根元素的\b株连性隐藏情况 计算溢出边界 根据溢出边界判断内容元素是否正常展示 其他同事调研 阿里的关于前端监控的文章： 前端监控 - 首屏统计的前世今生 监控平台只提供基础能力，由业务方自己配置，接受告警"}],"posts":[{"title":"从头撸一个webpack plugin","slug":"FE/从头撸一个webpack plugin","date":"2021-01-08T08:58:05.467Z","updated":"2021-01-08T11:11:04.546Z","comments":true,"path":"2021/01/08/FE/从头撸一个webpack plugin/","link":"","permalink":"http://example.com/2021/01/08/FE/%E4%BB%8E%E5%A4%B4%E6%92%B8%E4%B8%80%E4%B8%AAwebpack%20plugin/","excerpt":"","text":"参考链接https://juejin.cn/post/6844903713312604173#heading-19 https://juejin.cn/post/6844904095728271374 https://juejin.cn/post/6844904100237148173","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Webpack","slug":"前端/Webpack","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"}]},{"title":"滑动吸顶","slug":"FE/React native实现tab吸顶","date":"2021-01-08T08:58:05.465Z","updated":"2021-01-08T11:21:42.576Z","comments":true,"path":"2021/01/08/FE/React native实现tab吸顶/","link":"","permalink":"http://example.com/2021/01/08/FE/React%20native%E5%AE%9E%E7%8E%B0tab%E5%90%B8%E9%A1%B6/","excerpt":"","text":"一、使用 scrollView 实现1）stickyHeader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import * as React from &#39;react&#39;;import &#123; StyleSheet, Animated &#125; from &quot;react-native&quot;;&#x2F;** * 滑动吸顶效果组件 * @export * @class StickyHeader *&#x2F;export default class StickyHeader extends React.Component&#123; static defaultProps &#x3D; &#123; stickyHeaderY: -1, stickyScrollY: new Animated.Value(0) &#125; constructor(props) &#123; super(props); this.state &#x3D; &#123; stickyLayoutY: 0, &#125;; &#125; &#x2F;&#x2F; 兼容代码，防止没有传头部高度 _onLayout &#x3D; (event) &#x3D;&gt; &#123; this.setState(&#123; stickyLayoutY: event.nativeEvent.layout.y, &#125;); &#125; render() &#123; const &#123; stickyHeaderY, stickyScrollY, children, style &#125; &#x3D; this.props const &#123; stickyLayoutY &#125; &#x3D; this.state let y &#x3D; stickyHeaderY !&#x3D; -1 ? stickyHeaderY : stickyLayoutY; const translateY &#x3D; stickyScrollY.interpolate(&#123; inputRange: [-1, 0, y, y + 1], outputRange: [0, 0, 0, 1], &#125;); return ( &lt;Animated.View onLayout&#x3D; &#123; this._onLayout &#125; style &#x3D; &#123; [ style, styles.container, &#123; transform: [&#123; translateY &#125;] &#125; ]&#125; &gt; &#123; children &#125; &lt;&#x2F;Animated.View&gt; ) &#125;&#125;const styles &#x3D; StyleSheet.create(&#123; container: &#123; zIndex: 100 &#125;,&#125;); 2）使用1234567891011121314151617181920212223242526272829303132333435363738this.state &#x3D; &#123; scrollY: new Animated.Value(0), headHeight:-1&#125;;&lt;Animated.ScrollView style&#x3D;&#123;&#123; flex: 1 &#125;&#125; onScroll&#x3D;&#123; Animated.event( [&#123; nativeEvent: &#123; contentOffset: &#123; y: this.state.scrollY &#125; &#125; &#x2F;&#x2F; 记录滑动距离 &#125;], &#123; useNativeDriver: true &#125;) &#x2F;&#x2F; 使用原生动画驱动 &#125; scrollEventThrottle&#x3D;&#123;1&#125;&gt; &lt;View onLayout&#x3D;&#123;(e) &#x3D;&gt; &#123; let &#123; height &#125; &#x3D; e.nativeEvent.layout; this.setState(&#123; headHeight: height &#125;); &#x2F;&#x2F; 给头部高度赋值 &#125;&#125;&gt; &#x2F;&#x2F; 里面放入第一部分组件 &lt;&#x2F;View&gt; &lt;StickyHeader stickyHeaderY&#x3D;&#123;this.state.headHeight&#125; &#x2F;&#x2F; 把头部高度传入 stickyScrollY&#x3D;&#123;this.state.scrollY&#125; &#x2F;&#x2F; 把滑动距离传入 &gt; &#x2F;&#x2F; 里面放入第二部分组件 &lt;&#x2F;StickyHeader&gt; &#x2F;&#x2F; 这是第三部分的列表组件 &lt;FlatList data&#x3D;&#123;this.state.dataSource&#125; renderItem&#x3D;&#123;(&#123;item&#125;) &#x3D;&gt; this._createListItem(item)&#125; &#x2F;&gt; &lt;&#x2F;Animated.ScrollView&gt; 二、使用 sectionList 实现react-native 滑动吸顶效果 有好货 react-native 列表吸顶效果&amp;滑动渐变动画&amp;轮播渐变动画","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React Native","slug":"前端/React-Native","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/React-Native/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"React Native","slug":"React-Native","permalink":"http://example.com/tags/React-Native/"}]},{"title":"React Native","slug":"FE/React Native","date":"2021-01-08T08:58:05.464Z","updated":"2021-01-08T11:21:40.835Z","comments":true,"path":"2021/01/08/FE/React Native/","link":"","permalink":"http://example.com/2021/01/08/FE/React%20Native/","excerpt":"","text":"一、 JSX 语法​ 1） 变量要写在 {} 内部； ​ 2）render ( ) 返回的 HTML 需要使用（）包起来 二、常用组件2.1 View2.2 Text2.3 Image1）使用 Image 标签负责展示图片 标签内不许再添加子元素 标签必须设置宽高 1234567891011&#x2F;&#x2F; 本地图片&lt;Image source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;ic-arrow.png&#39;)&#125; style&#x3D;&#123;&#123; width: 12, height: 21 &#125;&#125; &gt;&lt;&#x2F;Image&gt;&#x2F;&#x2F; 图床&lt;Image source&#x3D;&#123;&#123;uri:&#39;https:&#x2F;&#x2F;...&#39;&#125;&#125; style&#x3D;&#123;&#123; width: 12, height: 21 &#125;&#125; &gt;&lt;&#x2F;Image&gt; 2）图片自适应可以再宽度固定的情况下动态计算图片的高度（参考） 12345678910111213141516 componentDidMount() &#123; let imageObj &#x3D; Image.resolveAssetSource( require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;pic-decorate.png&#39;) ) let &#123; width, height &#125; &#x3D; imageObj let myHeight &#x3D; Math.floor((getWidth() &#x2F; width) * height) this.setState(&#123; imgObjHg: myHeight, &#125;) &#125; &lt;Image source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;pic-decorate.png&#39;)&#125; style&#x3D;&#123;&#123; width: getWidth(), height: this.state.imgObjHg &#125;&#125; &gt;&lt;&#x2F;Image&gt; 2.3 ScrollView2.4 FlatList1) 多列布局： numColumns2）使用实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; Image, FlatList, StyleSheet, Text, View&#125; from &#x27;react-native&#x27;;const REQUEST_URL = &#x27;https://raw.githubusercontent.com/facebook/react-native/0.51-stable/docs/MoviesExample.json&#x27;;export default class SampleAppMovies extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; data: [], loaded: false &#125;; // 在ES6中，如果在自定义的函数里使用了this关键字，则需要对其进行“绑定”操作，否则this的指向会变为空 // 像下面这行代码一样，在constructor中使用bind是其中一种做法（还有一些其他做法，如使用箭头函数等） this.fetchData = this.fetchData.bind(this); &#125; componentDidMount() &#123; this.fetchData(); &#125; fetchData() &#123; fetch(REQUEST_URL) .then((response) =&gt; response.json()) .then((responseData) =&gt; &#123; // 注意，这里使用了this关键字，为了保证this在调用时仍然指向当前组件，我们需要对其进行“绑定”操作 this.setState(&#123; data: this.state.data.concat(responseData.movies), loaded: true &#125;); &#125;); &#125; render() &#123; if (!this.state.loaded) &#123; return this.renderLoadingView(); &#125; return ( &lt;FlatList data=&#123;this.state.data&#125; renderItem=&#123;this.renderMovie&#125; style=&#123;styles.list&#125; keyExtractor=&#123;(item) =&gt; item.id&#125; /&gt; ); &#125; renderLoadingView() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text&gt;Loading movies...&lt;/Text&gt; &lt;/View&gt; ); &#125; renderMovie(&#123; item &#125;) &#123; // &#123; item &#125;是一种“解构”写法，请阅读ES2015语法的相关文档 // item也是FlatList中固定的参数名，请阅读FlatList的相关文档 return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Image source=&#123;&#123; uri: item.posters.thumbnail &#125;&#125; style=&#123;styles.thumbnail&#125; /&gt; &lt;View style=&#123;styles.rightContainer&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.year&#125;&gt;&#123;item.year&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, flexDirection: &#x27;row&#x27;, justifyContent: &#x27;center&#x27;, alignItems: &#x27;center&#x27;, backgroundColor: &#x27;#F5FCFF&#x27; &#125;, rightContainer: &#123; flex: 1 &#125;, title: &#123; fontSize: 20, marginBottom: 8, textAlign: &#x27;center&#x27; &#125;, year: &#123; textAlign: &#x27;center&#x27; &#125;, thumbnail: &#123; width: 53, height: 81 &#125;, list: &#123; paddingTop: 20, backgroundColor: &#x27;#F5FCFF&#x27; &#125;&#125;); 3) 渲染多个子元素123456789101112131415_renderShop() &#123; return ( &lt;View&gt; &lt;Text&gt;店铺名字&lt;/Text&gt; &#123; this.products.map((item,index) =&gt; &#123; &lt;View&gt; //商品信息 &lt;/View&gt; &#125;) &#125; &lt;/View&gt; )&#125; 三、常用事件四、网络请求通常在 componentDidMount( ) 中获取请求 五、调试2.1 chrome 开发者工具 1）使用方式 2）优点 提供 console 输出 可在 source 中断点调试 js 脚本 熟悉 chrome 缺点 无法展示 App 界面 无法观察到 React Native 中的网络请求 2.2 Safari1）使用方式 打开调试：Preferences → Advanced → Select “Show Develop menu in menu bar” 选择 Develop → Simulator → JSContext 2.3 React Developer Tools1）安装 1yarn add -g react-devtools 2）执行命令 1react-devtools 参考链接React Native","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React Native","slug":"前端/React-Native","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/React-Native/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"React Native","slug":"React-Native","permalink":"http://example.com/tags/React-Native/"}]},{"title":"React Native 动画","slug":"FE/React Native 动画","date":"2021-01-08T08:58:05.463Z","updated":"2021-01-08T11:21:45.891Z","comments":true,"path":"2021/01/08/FE/React Native 动画/","link":"","permalink":"http://example.com/2021/01/08/FE/React%20Native%20%E5%8A%A8%E7%94%BB/","excerpt":"","text":"本次只记录用到的 API。 timing( )图片由小变大 1234567891011121314151617181920212223242526272829&#x2F;&#x2F; jsthis.state &#x3D; &#123; hair1AnimateOpacity: new Animated.Value(0), &#x2F;&#x2F; 声明动画初始状态 &#125;this.sequenceAnimated &#x3D; Animated.timing(this.hair1AnimateOpacity, &#123; toValue: 1, &#x2F;&#x2F;动画最终值 duration: 200, &#x2F;&#x2F;动画时长3000毫秒 easing: Easing.linear, &#125;), &#x2F;&#x2F; react native &lt;Animated.View style&#x3D;&#123;&#123; width: 126, height: 126, transform: [&#123; scale: this.state.hair1AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair1.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; spring（）根据基于阻尼谐振动 damped harmonic oscillation的弹性模型生成一个动画值。它会在toValue值更新的同时跟踪当前的速度状态，以确保动画连贯。可以链式调用。 12345678910111213141516171819202122232425262728 &#x2F;&#x2F; jsthis.state &#x3D; &#123; hair1AnimateOpacity: new Animated.Value(0), &#x2F;&#x2F; 声明动画初始状态 &#125; Animated.spring(this.state.hair1AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;), &#x2F;&#x2F; react native &lt;Animated.View style&#x3D;&#123;&#123; width: 126, height: 126, transform: [&#123; scale: this.state.hair1AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair1.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; sequence()按顺序执行一个动画数组里的动画，等待一个完成后再执行下一个。如果当前的动画被中止，后面的动画则不会继续执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import React from &#39;react&#39;import &#123; Image, View, StyleSheet, Text, Animated, TouchableOpacity, Easing,&#125; from &#39;@mrn&#x2F;react-native&#39;export interface OpacityProps &#123; isLoading: boolean&#125;export interface OpacityStates &#123; hair1AnimateOpacity: any hair2AnimateOpacity: any hair3AnimateOpacity: any hair4AnimateOpacity: any&#125;export default class LoadAnimation extends React.Component&lt; OpacityProps, OpacityStates&gt; &#123; sequenceAnimated: Animated.CompositeAnimation constructor(props) &#123; super(props) &#x2F;&#x2F; 声明动画初始值 this.state &#x3D; &#123; hair1AnimateOpacity: new Animated.Value(0), hair2AnimateOpacity: new Animated.Value(0), hair3AnimateOpacity: new Animated.Value(0), hair4AnimateOpacity: new Animated.Value(0), &#125; &#x2F;&#x2F; 动画队列，会依次执行动画 this.sequenceAnimated &#x3D; Animated.sequence([ Animated.spring(this.state.hair1AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;), Animated.timing(this.state.hair1AnimateOpacity, &#123; toValue: 0, &#x2F;&#x2F;透明度动画最终值 duration: 200, &#x2F;&#x2F;动画时长3000毫秒 easing: Easing.linear, &#125;), Animated.spring(this.state.hair2AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;), Animated.timing(this.state.hair2AnimateOpacity, &#123; toValue: 0, &#x2F;&#x2F;透明度动画最终值 duration: 200, &#x2F;&#x2F;动画时长3000毫秒 easing: Easing.linear, &#125;), Animated.spring(this.state.hair3AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;), Animated.timing(this.state.hair3AnimateOpacity, &#123; toValue: 0, &#x2F;&#x2F;透明度动画最终值 duration: 200, &#x2F;&#x2F;动画时长3000毫秒 easing: Easing.linear, &#125;), Animated.spring(this.state.hair4AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;), Animated.timing(this.state.hair4AnimateOpacity, &#123; toValue: 0, &#x2F;&#x2F;透明度动画最终值 duration: 200, &#x2F;&#x2F;动画时长3000毫秒 easing: Easing.linear, &#125;), ]) &#125; &#x2F;&#x2F; 调用动画 _startAnimated() &#123; this.sequenceAnimated.start() &#125; render() &#123; return ( &lt;View style&#x3D;&#123;styles.mainStyle&#125;&gt; &lt;Animated.View style&#x3D;&#123;&#123; width: 126, height: 126, transform: [&#123; scale: this.state.hair1AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair1.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; &lt;Animated.View style&#x3D;&#123;&#123; position: &#39;absolute&#39;, width: 126, height: 126, transform: [&#123; scale: this.state.hair2AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair2.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; &lt;Animated.View style&#x3D;&#123;&#123; position: &#39;absolute&#39;, width: 126, height: 126, transform: [&#123; scale: this.state.hair3AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair3.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; &lt;Animated.View style&#x3D;&#123;&#123; position: &#39;absolute&#39;, width: 126, height: 126, transform: [&#123; scale: this.state.hair4AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair4.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; &lt;TouchableOpacity style&#x3D;&#123;styles.touchStyle&#125; onPress&#x3D;&#123;this._startAnimated.bind(this)&#125; &gt; &lt;Text style&#x3D;&#123;&#123; width: 200, height: 100, textAlign: &#39;center&#39;, lineHeight: 100, &#125;&#125; &gt; 点击开始动画 &lt;&#x2F;Text&gt; &lt;&#x2F;TouchableOpacity&gt; &lt;&#x2F;View&gt; ) &#125;&#125; 动画循环动画循环是最常用的一个场景，本次需求就要求对动画做一个循环效果。 查阅了官方文档 和网上的一些资料，总结了两类实现动画循环的效果。 1）单动画循环 loop( )这个不多说，可以直接看官方文档 1234567Animate.loop( Animated.spring(this.state.hair1AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;)) 2）动画队列循环动画的 start( ) 方法可以传递回调函数，因此在动画结束时再次回调就可以很方便的实现动画循环了。 1234_startAnimated() &#123; Animated.sequence(animations).start(() &#x3D;&gt; this._startAnimated())&#125; 最后贴出完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187import React from &#39;react&#39;import &#123; Image, View, StyleSheet, Text, Animated, TouchableOpacity, Easing,&#125; from &#39;@mrn&#x2F;react-native&#39;export interface OpacityProps &#123; isLoading: boolean&#125;export interface OpacityStates &#123; hair1AnimateOpacity: any hair2AnimateOpacity: any hair3AnimateOpacity: any hair4AnimateOpacity: any&#125;export default class LoadAnimation extends React.Component&lt; OpacityProps, OpacityStates&gt; &#123; &#x2F;&#x2F; hair1AnimateOpacity: Animated.Value &#x2F;&#x2F; hair2AnimateOpacity: Animated.Value &#x2F;&#x2F; hair3AnimateOpacity: Animated.Value &#x2F;&#x2F; hair4AnimateOpacity: Animated.Value sequenceAnimated: Animated.CompositeAnimation constructor(props) &#123; super(props) this.state &#x3D; &#123; hair1AnimateOpacity: new Animated.Value(0), hair2AnimateOpacity: new Animated.Value(0), hair3AnimateOpacity: new Animated.Value(0), hair4AnimateOpacity: new Animated.Value(0), &#125; &#125; onSpringCompletion &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; TODO if (this.props.isLoading || 1) &#123; this._startAnimated() &#125; &#125; _startAnimated() &#123; Animated.sequence([ Animated.spring(this.state.hair1AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;), Animated.timing(this.state.hair1AnimateOpacity, &#123; toValue: 0, &#x2F;&#x2F;透明度动画最终值 duration: 200, &#x2F;&#x2F;动画时长3000毫秒 easing: Easing.linear, &#125;), Animated.spring(this.state.hair2AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;), Animated.timing(this.state.hair2AnimateOpacity, &#123; toValue: 0, &#x2F;&#x2F;透明度动画最终值 duration: 200, &#x2F;&#x2F;动画时长3000毫秒 easing: Easing.linear, &#125;), Animated.spring(this.state.hair3AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;), Animated.timing(this.state.hair3AnimateOpacity, &#123; toValue: 0, &#x2F;&#x2F;透明度动画最终值 duration: 200, &#x2F;&#x2F;动画时长3000毫秒 easing: Easing.linear, &#125;), Animated.spring(this.state.hair4AnimateOpacity, &#123; toValue: 1, friction: 3, &#x2F;&#x2F;弹跳系数 tension: 10, &#x2F;&#x2F; 控制速度 &#125;), Animated.timing(this.state.hair4AnimateOpacity, &#123; toValue: 0, &#x2F;&#x2F;透明度动画最终值 duration: 200, &#x2F;&#x2F;动画时长3000毫秒 easing: Easing.linear, &#125;), ]).start(() &#x3D;&gt; this.onSpringCompletion()) &#125; render() &#123; return ( &lt;View style&#x3D;&#123;styles.mainStyle&#125;&gt; &lt;Animated.View style&#x3D;&#123;&#123; width: 126, height: 126, transform: [&#123; scale: this.state.hair1AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair1.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; &lt;Animated.View style&#x3D;&#123;&#123; position: &#39;absolute&#39;, width: 126, height: 126, transform: [&#123; scale: this.state.hair2AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair2.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; &lt;Animated.View style&#x3D;&#123;&#123; position: &#39;absolute&#39;, width: 126, height: 126, transform: [&#123; scale: this.state.hair3AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair3.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; &lt;Animated.View style&#x3D;&#123;&#123; position: &#39;absolute&#39;, width: 126, height: 126, transform: [&#123; scale: this.state.hair4AnimateOpacity &#125;], &#125;&#125; &gt; &lt;Image ref&#x3D;&quot;image&quot; style&#x3D;&#123;&#123; width: 126, height: 126, &#125;&#125; source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;hair4.png&#39;)&#125; &gt;&lt;&#x2F;Image&gt; &lt;&#x2F;Animated.View&gt; &lt;TouchableOpacity style&#x3D;&#123;styles.touchStyle&#125; onPress&#x3D;&#123;this._startAnimated.bind(this)&#125; &gt; &lt;Text style&#x3D;&#123;&#123; width: 200, height: 100, textAlign: &#39;center&#39;, lineHeight: 100, &#125;&#125; &gt; 点击开始动画 &lt;&#x2F;Text&gt; &lt;&#x2F;TouchableOpacity&gt; &lt;&#x2F;View&gt; ) &#125;&#125;const styles &#x3D; StyleSheet.create(&#123; mainStyle: &#123;&#125;, touchStyle: &#123;&#125;,&#125;) ​ 参考文章React Native 动画（Animated） ReactNative Animated 动画详解 官方文档-动画 官方文档—API","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React Native","slug":"前端/React-Native","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/React-Native/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"React Native","slug":"React-Native","permalink":"http://example.com/tags/React-Native/"}]},{"title":"ScrollToView——将某元素滚动到指定位置","slug":"FE/React Native scrollToView","date":"2021-01-08T08:58:05.462Z","updated":"2021-01-08T11:27:37.846Z","comments":true,"path":"2021/01/08/FE/React Native scrollToView/","link":"","permalink":"http://example.com/2021/01/08/FE/React%20Native%20scrollToView/","excerpt":"","text":"FlatList方案推荐使用该方案 FlatList 有个 scrollToIndex(params)，可以直接实现该功能。 参数params： 类型object，包含以下 key ‘animated’ (boolean) - Whether the list should do an animation while scrolling. Defaults to true. ‘index’ (number) - The index to scroll to. Required. ‘viewOffset’ (number) - A fixed number of pixels to offset the final target position. ‘viewPosition’ (number) - A value of 0 places the item specified by index at the top, 1 at the bottom, and 0.5 centered in the middle. scrollView 实现方案scrollView 实现该功能的思路为 计算要滚动的距离 + scrollTo( )来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import React, &#123; Component &#125; from &#39;react&#39;;import &#123; StyleSheet, Text, View, ScrollView, TouchableOpacity, Dimensions, Alert, findNodeHandle, Image &#125; from &#39;react-native&#39;;class MyCustomScrollToElement extends Component &#123;constructor(props) &#123; super(props) this.state &#x3D; &#123; &#125; this._nodes &#x3D; new Map();&#125;componentDidMount() &#123; const data &#x3D; [&#39;First Element&#39;, &#39;Second Element&#39;, &#39;Third Element&#39;, &#39;Fourth Element&#39;, &#39;Fifth Element&#39; ]; data.filter((el, idx) &#x3D;&gt; &#123; if(el&#x3D;&#x3D;&#x3D;this.props.id)&#123; this.scrollToElement(idx); &#125; &#125;)&#125;scrollToElement &#x3D;(indexOf)&#x3D;&gt;&#123; const node &#x3D; this._nodes.get(indexOf); const position &#x3D; findNodeHandle(node); this.myScroll.scrollTo(&#123; x: 0, y: position, animated: true &#125;);&#125;render()&#123; const data &#x3D; [&#39;First Element&#39;, &#39;Second Element&#39;, &#39;Third Element&#39;, &#39;Fourth Element&#39;, &#39;Fifth Element&#39; ]; return ( &lt;View style&#x3D;&#123;styles.container&#125;&gt; &lt;ScrollView ref&#x3D;&#123;(ref) &#x3D;&gt; this.myScroll &#x3D; ref&#125; style&#x3D;&#123;[styles.container, &#123;flex:0.9&#125;]&#125; keyboardShouldPersistTaps&#x3D;&#123;&#39;handled&#39;&#125;&gt; &lt;View style&#x3D;&#123;styles.container&#125;&gt; &#123;data.map((elm, idx) &#x3D;&gt; &lt;View ref&#x3D;&#123;ref &#x3D;&gt; this._nodes.set(idx, ref)&#125; style&#x3D;&#123;&#123;styles.element&#125;&#125;&gt;&lt;Text&gt;&#123;elm&#125;&lt;&#x2F;Text&gt;&lt;&#x2F;View&gt;)&#125; &lt;&#x2F;View&gt; &lt;&#x2F;ScrollView&gt; &lt;&#x2F;View&gt;);import React, &#123; Component &#125; from &#39;react&#39;;import &#123; StyleSheet, Text, View, ScrollView, TouchableOpacity, Dimensions, Alert, findNodeHandle, Image &#125; from &#39;react-native&#39;;class MyCustomScrollToElement extends Component &#123;constructor(props) &#123; super(props) this.state &#x3D; &#123; &#125; this._nodes &#x3D; new Map();&#125;componentDidMount() &#123; const data &#x3D; [&#39;First Element&#39;, &#39;Second Element&#39;, &#39;Third Element&#39;, &#39;Fourth Element&#39;, &#39;Fifth Element&#39; ]; data.filter((el, idx) &#x3D;&gt; &#123; if(el&#x3D;&#x3D;&#x3D;this.props.id)&#123; this.scrollToElement(idx); &#125; &#125;)&#125;scrollToElement &#x3D;(indexOf)&#x3D;&gt;&#123; const node &#x3D; this._nodes.get(indexOf); const position &#x3D; findNodeHandle(node); this.myScroll.scrollTo(&#123; x: 0, y: position, animated: true &#125;);&#125;render()&#123; const data &#x3D; [&#39;First Element&#39;, &#39;Second Element&#39;, &#39;Third Element&#39;, &#39;Fourth Element&#39;, &#39;Fifth Element&#39; ]; return ( &lt;View style&#x3D;&#123;styles.container&#125;&gt; &lt;ScrollView ref&#x3D;&#123;(ref) &#x3D;&gt; this.myScroll &#x3D; ref&#125; style&#x3D;&#123;[styles.container, &#123;flex:0.9&#125;]&#125; keyboardShouldPersistTaps&#x3D;&#123;&#39;handled&#39;&#125;&gt; &lt;View style&#x3D;&#123;styles.container&#125;&gt; &#123;data.map((elm, idx) &#x3D;&gt; &lt;View ref&#x3D;&#123;ref &#x3D;&gt; this._nodes.set(idx, ref)&#125; style&#x3D;&#123;&#123;styles.element&#125;&#125;&gt;&lt;Text&gt;&#123;elm&#125;&lt;&#x2F;Text&gt;&lt;&#x2F;View&gt;)&#125; &lt;&#x2F;View&gt; &lt;&#x2F;ScrollView&gt; &lt;&#x2F;View&gt;);","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React Native","slug":"前端/React-Native","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/React-Native/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"React Native","slug":"React-Native","permalink":"http://example.com/tags/React-Native/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Webpack","slug":"前端/Webpack","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Webpack/"},{"name":"React Native","slug":"前端/React-Native","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/React-Native/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"React Native","slug":"React-Native","permalink":"http://example.com/tags/React-Native/"}]}